<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <title>02. AlphaFold3 离线版使用说明 - 海钊知识港</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="collection" content="alphafold"> 
        <meta name="collection-title" content="AlphaFold">
        <meta name="parent-path" content="../../dry_lab_index.html">
        <meta name="parent-title" content="干实验">
        <meta name="date" content="2026-01-19">
        <meta name="description" content="在集群上部署AlphaFold实现任意小分子对接的蛋白质共预测">

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
        <link rel="stylesheet" href="../../../../css/global.css">
        
        <script>window.footerPath = '../../../../footer.html';</script>
        <script src="../../../../js/global.js"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>

    <body class="article-page">
        <nav>
            <div class="logo"><a href="../../../../index.html">海钊知识港</a></div>
            <div class="nav-links">
                <a href="../../../wet_lab/wet_lab_index.html"><i class="fas fa-flask"></i> 湿实验</a>
                <a href="../../dry_lab_index.html" class="active"><i class="fas fa-code"></i> 干实验</a>
                <a href="../../../resources/resources_index.html"><i class="fas fa-book"></i> 资源站</a>
                <a href="../../../about/about_index.html"><i class="fas fa-user"></i> 关于我</a>
            </div>
        </nav>

        <div class="article-container">
            <h1>02. AlphaFold3 离线版使用说明</h1>
            
            <div class="content">
                <h2>前言</h2>
                <p>离线版版本的 AlphaFold3 (AF3) 相比在线版本可以支持任意小分子的对接共预测。我们使用传统的分子对接例如 Vian 一般都进行刚性对接和半柔性对接，而受体与配体的生物学结合一般都存在较大的构象改变。因此使用 AlphaFold 同时预测＋对接，可以极大的提高预测精度和对接精度，这也是 AF3 最为先进的一点。本文以 slurm 任务提交集群作业为例。</p>
                <h2>1. 资源核实</h2>
                <p>由于 AF3 模型在进行结构推理和扩散模型优化时，对 GPU 的张量计算能力及显存容量有极高要求（单次任务显存需求通常超过 40GB），所以在进行任务前我们务必需要检查配置，后续以集群查询为例。</p>
                <p>另外别忘记查看集群或服务器是否本地部署了 AF3 。</p>
                <ol>
                    <li>查看分区</li>
                    <p>输入以下命令查看所有分区的简要状态：</p>
                    <pre><code class="language-bash">sinfo</code></pre>
                    <p>其中一个 Partition 就是一个分区，它用于管理用户对这个分区下节点使用的权限，如果你没有这个分区的使用权限，那你就调用不了这个分区下的节点资源。</p>
                    <pre><code class="language-bash">
PARTITION        AVAIL  TIMELIMIT  NODES  STATE NODELIST
Partition1          up   infinite     10    mix cu[01-03]
Partition2          up   infinite     10  alloc cu04
Partition3          up   infinite     10 drain* cu[02-04]
Partition4          up   infinite     10  drain cu[08,38-39,72,96-97]
Partition5          up   infinite     10    mix cu[01,03]
                    </code></pre>
                    <li>查看分区可用资源</li>
                    <p>输入以下命令查看所有分区的资源：</p>
                    <pre><code class="language-bash">sinfo -o "%20P %20G %10D %c %m"</code></pre>
                    <p>注意 GRES 这一列，如果为 (null) 就代表着这个分区下没有显卡资源，需要使用有显卡的分区：</p>
                    <pre><code class="language-bash">
PARTITION            GRES                  NODES      CPUS MEMORY
Partition1           (null)                8          512  2000000
Partition2           (null)                8          512  2000000
Partition3           gpu:nvidia_h100-sxm4  8          512  2000000
                    </code></pre>
                </ol>
                <h2>2. 任务文件编写</h2>
                    <p>AF3 的每一次对接任务都是以一个<code>.json</code>文件来储存的，里面包含你要预测的氨基酸序列，配体小分子的 smiles 表达，当然还支持其它互作对象共预测，我们就继续以小分子对接为例，其 AF3 离线版本标准<code>.json</code>写法如下：</p>
                    <pre><code class="language-json">
{
    "name": "Fs001365_t01",
    "dialect": "alphafold3",
    "version": 1,
    "sequences": [
        {
        "protein": {
            "id": "A",
            "sequence": "MDIDSYRYRVPKP......"
        }
        },
        {
        "ligand": {
            "id": "B",
            "smiles": "C[C@H](/C=C(\\C)/C=C/C(=O)NO)C(=O)C1=CC=C(C=C1)N(C)C"
        }
        }
    ],
    "modelSeeds": [1]
}
                    </code></pre>
                    <p>其中<code>sequence</code>为氨基酸序列，<code>smiles</code>为配体小分子的 smiles 表达。</p>
                    <blockquote><p>当我们有大量的序列需要预测对接时，我们一般会存放在一个<code>.fasta</code>文件中，此时直接运行相关脚本，会自动生成所有的任务标准文件。</p></blockquote>
                <h2>3. 创建工作目录</h2>
                <pre><code class="language-bash">
.
├── 0.json              # 存放预测任务文件
│   ├── task_01.json
│   └── task_02.json
└ task.slurm            # 存放集群slurem任务提交文件
                </code></pre>
                <p>其中，输出文件夹和单次任务的对接日志输出会自动生成，无需担心。</p>
                <h2>4. 编写任务提交文件</h2>
                <p>因为我们是在集群服务器上进行任务，一般来说集群服务器都是以作业队列方式提交任务的，因此我们要写一个<code>.slurm</code>任务提交文件。</p>
                <p>一次对接任务就要单独执行一次任务递交，我们先进行单次任务尝试提交，如果能正常运行，我们稍后会写一个脚本进行批量提交：</p>
                <pre><code class="language-bash">
                    #!/bin/bash
                    #SBATCH --job-name="task_01"            # 该次提交任务的名字
                    #SBATCH --partition=example             # 提交队列
                    #SBATCH --nodes=1
                    #SBATCH --ntasks=1
                    #SBATCH --cpus-per-task=32 
                    #SBATCH --gres=gpu:nvidia_h100-sxm4:1   # 指定调用显卡型号
                    #SBATCH --time=2:00:00                  # 任务运行最长时间，两小时足够了
                    #SBATCH --error=%j.error.log            # 输出错误日志
                    #SBATCH --output=%j.stdout.log          # 输出标准日志
                    
                    # 1. 加载必要的环境
                    module load singularity/4.3.3           # 加载对接命令，如果系统默认环境变量有就不用管它
                    module load python/3.11.1               # 加载python环境，一般AF3内置有，错误日志会报错，不用管它

                    
                    # 2. 设置用户工作路径
                    export AF3_USER_PATH=/home/user_name/af3_work_dir       # 注意修改工作目录
                    export AF3_INPUT=${AF3_USER_PATH}/0.json/task_01.json
                    export AF3_OUTPUT=${AF3_USER_PATH}/output
                    
                    # 3. 设置集群公共资源路径
                    export AF3_RESOURCES_DIR=/data/AlphaFold3
                    export AF3_IMAGE=${AF3_RESOURCES_DIR}/images/alphafold3.sif
                    export AF3_CODE_DIR=${AF3_RESOURCES_DIR}/alphafold3
                    export AF3_MODEL_PARAMETERS_DIR=${AF3_RESOURCES_DIR}/weights
                    export AF3_DATABASES_DIR=${AF3_RESOURCES_DIR}/databases
                    
                    # 4. 确保输出目录存在
                    mkdir -p $AF3_OUTPUT
                    
                    echo "开始为 ${AF3_INPUT} 执行 AlphaFold 3 计算..."
                    
                    # 5. 调用 Singularity 容器运行 AF3
                    singularity exec \
                      --nv \
                      --bind $AF3_INPUT:/root/af_input \
                      --bind $AF3_OUTPUT:/root/af_output \
                      --bind $AF3_MODEL_PARAMETERS_DIR:/root/models \
                      --bind $AF3_DATABASES_DIR:/root/public_database \
                      --bind $AF3_CODE_DIR:/root/af3code \
                      $AF3_IMAGE \
                      python3 /root/af3code/run_alphafold.py \
                      --json_path=/root/af_input \
                      --model_dir=/root/models \
                      --db_dir=/root/public_database \
                      --output_dir=/root/af_output
                </code></pre>
                <p>保存为<code>task_01.slurm</code>文件，进行提交：</p>
                <pre><code class="language-bash">sbatch task_01.slurm </code></pre>
                <p>提交后会显示任务ID，使用如下命令查看任务状态：</p>
                <pre><code class="language-bash">
                    sacct -j 任务ID --format=JobID,JobName,State,ExitCode,Elapsed
                </code></pre>
                <pre><code class="language-bash">
JobID           JobName      State ExitCode    Elapsed 
------------ ---------- ---------- -------- ---------- 
00001        000001_do+    RUNNING      0:0   00:05:00 
00001.batch       batch    RUNNING      0:0   00:05:00 
00001.extern     extern    RUNNING      0:0   00:05:00 
                </code></pre>
                <p>并时刻注意日志，以免发生了报错还不知道。</p>
                <p>当标准输出日志<code>.stdout.log</code>出现：</p>
                <pre><code class="language-bash">Done running 1 fold jobs.</code></pre>
                <p>则说明该次预测对接结束，进入 output 文件夹进行查看。</p>
                <h2>5. 自动化</h2>
                <h3>5.1 对接任务文件生成</h3>
                <p>准备材料：<ol>
                    <li>整个待预测蛋白的<code>.fasta</code>氨基酸序列。</li>
                    <li>所有对接小分子的<code>SMILES</code>文件，为方便管理，按照以下样式记录，保存为<code>.smiles</code>文件。</li>
                    <pre><code class="language-txt">
>ATP
C1=NC(=C2C(=N1)N(C=N2)[C@H]3[C@@H]([C@@H]([C@H](O3)COP(=O)(O)OP(=O)(O)OP(=O)(O)O)O)O)N.C1=NC(=C2C(=N1)N(C=N2)[C@H]3[C@@H]([C@@H]([C@H](O3)COP(=O)(O)OP(=O)(O)OP(=O)(O)O)O)O)N
>NADPH
C1C=CN(C=C1C(=O)N)[C@H]2[C@@H]([C@@H]([C@H](O2)COP(=O)(O)OP(=O)(O)OC[C@@H]3[C@H]([C@H]([C@@H](O3)N4C=NC5=C(N=CN=C54)N)OP(=O)(O)O)O)O)O
>58880-19-6
C[C@H](/C=C(\\C)/C=C/C(=O)NO)C(=O)C1=CC=C(C=C1)N(C)C
                    </code></pre>
                    <li>脚本。</li>
                </ol></p>
                <p>运行脚本<code>01. 对接任务生成.py</code>，自动生成所有的 AF3 任务文件：</p>
                    <pre><code class="language-Plaintext">
JSON/
├── ATP/
│   ├── ATP_PEP_01.json
│   ├── ATP_PEP_02.json
│   └── ...
├── NADPH/
│   ├── NADPH_PEP_01.json
│   └── ...
                    </code></pre>
                <h3>5.2 集群任务部署</h3>
                <p>迁移文件及任务提交脚本。确保你的目录结构在集群是这样的：</p>
                <pre><code class="language-Plaintext">
./
├── JSON/               (由上一步脚本生成的文件夹)
│   ├── ATP/
│   │   └── ...json
│   └── ...
└── 2. 任务提交.py
                </code></pre>
                <p>执行脚本，任务提交。</p>
                <pre><code class="language-bash">python 02. 任务提交.py</code></pre>
                <pre><code class="language-bash">
准备提交 200 个任务...
结果目录: Results/<CAS_ID>/<Task_Name>
日志目录: Logs/<CAS_ID>/
确认开始提交? (y/n): y
[1/200] 提交: ATP_PEP_01 ... 成功 (JobID: 00001)
[2/200] 提交: ATP_PEP_01 ... 成功 (JobID: 00002)
[3/200] 提交: ATP_PEP_01 ... 成功 (JobID: 00003)
[4/200] 提交: ATP_PEP_01 ... 成功 (JobID: 00004)
[5/200] 提交: ATP_PEP_01 ... 成功 (JobID: 00005)
[6/200] 提交: ATP_PEP_01 ... 成功 (JobID: 00006)
......
--------------------------------------------------
完成! 成功提交 200/200 个任务。
使用 'squeue -u user_name' 查看队列状态。           # 这个命令在有些集群上无法正常显示，请留意输出日志。
                </code></pre>
                <p>同样，实时注意着输出日志，不要报错了还没发现。</p>
                <pre><code class="language-Plaintext">
./
├── Results/
│   └── ATP/
│       └── ATP_PEP_01/  (结果存放在这里)
│           └── seed-1_sample-0.json ...
├── Logs/
│   └── ATP/
│       ├── ATP_PEP_01.out
│       └── ATP_PEP_01.err
                </code></pre>
                <p>输出查看请看后续文章。</p>
                <h3>5.3 数据矩阵汇总</h3>
                <p>运行数据汇总脚本，分别生成ipTM，pTM得分矩阵。</p>
            </div>
        </div>

        <div id="footer-placeholder"></div>
    </body>
</html>