<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <title>01. 隐马尔可夫模型 - 海钊知识港</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="collection" content="algorithm"> 
        <meta name="collection-title" content="算法">
        <meta name="parent-path" content="../../dry_lab_index.html">
        <meta name="parent-title" content="干实验">
        <meta name="date" content="2026-01-24">
        <meta name="description" content="通过观测序列推测未知序列">

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
        <link rel="stylesheet" href="../../../../css/global.css">
        
        <script>window.footerPath = '../../../../footer.html';</script>
        <script src="../../../../js/global.js"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>

    <body class="article-page">
        <nav>
            <div class="logo"><a href="../../../../index.html">海钊知识港</a></div>
            <div class="nav-links">
                <a href="../../../wet_lab/wet_lab_index.html"><i class="fas fa-flask"></i> 湿实验</a>
                <a href="../../dry_lab_index.html" class="active"><i class="fas fa-code"></i> 干实验</a>
                <a href="../../../resources/resources_index.html"><i class="fas fa-book"></i> 资源站</a>
                <a href="../../../about/about_index.html"><i class="fas fa-user"></i> 关于我</a>
            </div>
        </nav>

        <div class="article-container">
            <h1>01. 隐马尔可夫模型</h1>
            
            <div class="content">
                <h2>前言</h2>
                <p>存在两个序列，一个是状态序列，一个是输出序列，这就是马尔可夫链。当状态序列隐藏时，就称为隐马尔可夫链。我们的目的是根据输出序列来推测状态序列。这就是隐马尔可夫模型 (Hidden Markov Model, HMM)的解码，寻找最可能的能产生某一特定输出序列的隐含状态的序列。</p>
                    <figure>
                        <img src="HMM.svg" alt="HMM">
                        
                        <figcaption>
                            <strong>图 1.</strong> HMM 的状态序列与输出序列
                        </figcaption>
                    </figure>
                <h2>1. 条件设定</h2>
                <p>我们假设前三天的天气为状态序列，即我们不知道，需要推算的序列。而这三天天气下对应的行动为观测序列，就是我们已知的观测序列，我们需要根据行动序列推算天气序列。</p>
                <p>为了简便，我们假设天气为晴天、阴天、雨天。行动为跑步、逛街、睡觉。</p>
                <p>天气之间存在着转换概率：</p>
                    <table>
                        <caption>
                            <strong>表 1.</strong> 天气序列之间转换概率
                        </caption>
                        <thead>
                            <tr>
                                <th>昨日 | 今日</th>
                                <th>晴天</th>
                                <th>阴天</th>
                                <th>雨天</th>
                                <th>概率合计</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>晴天</td>
                                <td>0.7</td>
                                <td>0.2</td>
                                <td>0.1</td>
                                <td>1.0</td>
                            </tr>
                            <tr>
                                <td>阴天</td>
                                <td>0.4</td>
                                <td>0.5</td>
                                <td>0.1</td>
                                <td>1.0</td>
                            </tr>
                            <tr>
                                <td>雨天</td>
                                <td>0.3</td>
                                <td>0.4</td>
                                <td>0.3</td>
                                <td>1.0</td>
                            </tr>
                        </tbody>
                    </table>
                <p>每天对应的行动也有概率：</p>
                    <table>
                        <caption>
                            <strong>表 2.</strong> 天气序列与行动序列之间对应概率
                        </caption>
                        <thead>
                            <tr>
                                <th>天气 | 行动</th>
                                <th>跑步</th>
                                <th>逛街</th>
                                <th>睡觉</th>
                                <th>概率合计</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>晴天</td>
                                <td>0.7</td>
                                <td>0.2</td>
                                <td>0.1</td>
                                <td>1.0</td>
                            </tr>
                            <tr>
                                <td>阴天</td>
                                <td>0.2</td>
                                <td>0.3</td>
                                <td>0.5</td>
                                <td>1.0</td>
                            </tr>
                            <tr>
                                <td>雨天</td>
                                <td>0.1</td>
                                <td>0.2</td>
                                <td>0.7</td>
                                <td>1.0</td>
                            </tr>
                        </tbody>
                    </table>
                <blockquote>注意，这里只有行概率合计为 1，列和概率为 1 则没有实际意义。</blockquote>
                <p>我们不知道第一天的前一天天气，所以我们需要一个初始概率，用来描述随机的一天各种天气出现的概率，我们假设初始随机概率为：</p>
                    <table>
                        <caption>
                            <strong>表 3.</strong> 初始概率
                        </caption>
                        <thead>
                            <tr>
                                <th>天气</th>
                                <th>晴天</th>
                                <th>阴天</th>
                                <th>雨天</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>初始概率</td>
                                <td>0.5</td>
                                <td>0.2</td>
                                <td>0.3</td>
                            </tr>
                        </tbody>
                    </table>
                <h2>2. 例子</h2>
                <p>假设连续三日的行动是睡觉、跑步、逛街，求这三日的天气。</p>
                <blockquote>
                    为方便表示，我们记事件：<br>
                    状态序列$x_{i}j$，$i\subset \{1, 2, 3\}$，$j\subset \{晴天, 阴天, 雨天\}$。<br>
                    观测序列$y_{i}k$，$i\subset \{1, 2, 3\}$，$k\subset \{跑步, 逛街, 睡觉\}$。
                </blockquote>
                <p>根据贝叶斯定理，第 $i$ 天行动为 $k$ 时，第 $i$ 天天气为 $j$ 的概率为：</p>
                <p>$$P(x_{i}j|y_{i}k)=\frac{P(y_{i}k|x_{i}j)\cdot P(x_{i}j)}{P(y_{i}k)}$$</p>
                <p>根据 Viterbi 公式，时刻 $i$ 处于状态 $j$ 的最大路径概率为：</p>
                <p>$$\delta_i(j) = {\left[ \max_{j' \in \{晴,阴,雨\}} \left( \delta_{i-1}(j') \times P(x_i j | x_{i-1} j') \right) \right]}\times P(y_i k | x_i j) (i>1)$$</p>
                <p>$$\delta_1(j) = {P(x_1 j)} \times {P(y_1 k | x_1 j)}(i=1)$$</p>
                <blockquote> 
                    Viterbi 公式和贝叶斯公式有着形式上的相似性，其区别在于：<br>
                    1. 在维特比算法中，为了找“最优路径”，我们将 “和”（$P(x_{i}j)$） 强行替换成了 “最大值”（max）。<br>
                    2. 在维特比算法的实际计算中，我们通常直接省去分母（$P(y_{i}k)$），因为在取最大值时都具有分母，为了计算简便，我们直接令其为 1。
                </blockquote>
                <blockquote>
                    这里需要注意理解的是两个概率有着不同的数学意义：贝叶斯概率是当天天气的概率，维特比中的路径概率是由上一天某种天气到今天某种天气的概率。贝叶斯概率忽略了路径的概念，而是直接将上一天所有天气到今天某种天气概率相加。<br>
                    具体来看，贝叶斯概率只有 $P(x_{i}j)$，而路径概率考虑到起始 $\delta_{i-1}(j')$ 到终点 $P(x_i j | x_{i-1} j')$。
                </blockquote>
                <h3>2.1 第一天</h3>
                <p>我们先来求第一天天气，当第一天睡觉时，根据 Viterbi 公式，第一天为晴天、阴天、雨天的概率公式为：</p>
                <p>$$\delta_1(j) = {P(x_1 j)} \times {P(y_1 睡觉 | x_1 j)}(i=1)$$</p>
                <blockquote>根据表三，$P(x_{1}j)$为初始概率：<br>
                    $P(x_{1}晴) = 0.5$<br>
                    $P(x_{1}阴) = 0.2$<br>
                    $P(x_{1}雨) = 0.3$
                </blockquote>
                <p>进行具体计算：</p>
                <p>$$\delta_1(晴) = {P(x_1 晴)} \times {P(y_1 睡觉 | x_1 晴)} = 0.5 \times 0.1 = 0.05$$</p>
                <p>$$\delta_1(阴) = {P(x_1 阴)} \times {P(y_1 睡觉 | x_1 阴)} = 0.2 \times 0.5 = 0.10$$</p>
                <p>$$\delta_1(雨) = {P(x_1 雨)} \times {P(y_1 睡觉 | x_1 雨)} = 0.3 \times 0.7 = 0.21$$</p>
                <h3>2.2 第二天</h3>
                <p>当第二天跑步时，第二天为晴天、阴天、雨天的概率公式为：</p>
                <p>$$\delta_2(j) = {\left[ \max_{j' \in \{晴,阴,雨\}} \left( \delta_{1}(j') \times P(x_2 j | x_{1} j') \right) \right]}\times P(y_2 跑步 | x_2 j)$$</p>
                <p>以晴天为例，进行具体计算：</p>
                <p>$$\delta_2(晴) = {\left[ \max_{j' \in \{晴,阴,雨\}} \left( \delta_{1}(j') \times P(x_2 晴 | x_{1} j') \right) \right]}\times P(y_2 跑步 | x_2 晴)$$</p>
                <p>看哪种 “昨天” 能让 “今天晴天” 的概率最大，再乘上 “跑步” 的概率。</p>
                <p>假如昨天是晴：</p>
                <p>$$\delta_{1}(j') \times P(x_2 晴 | x_{1} j') = \delta_{1}(晴) \times P(x_2 晴 | x_{1} 晴) = 0.05 \times 0.7 = 0.035$$</p>
                <p>假如昨天是阴：</p>
                <p>$$\delta_{1}(j') \times P(x_2 晴 | x_{1} j') = \delta_{1}(阴) \times P(x_2 晴 | x_{1} 阴) = 0.10 \times 0.4 = 0.040$$</p>
                <p>假如昨天是雨：</p>
                <p>$$\delta_{1}(j') \times P(x_2 晴 | x_{1} j') = \delta_{1}(雨) \times P(x_2 晴 | x_{1} 雨) = 0.21 \times 0.3 = 0.063$$</p>
                <p>综上，有：</p>
                <p>$$\left[ \max_{j' \in \{晴,阴,雨\}} \left( \delta_{1}(j') \times P(x_2 晴 | x_{1} j') \right) \right] = 0.063$$</p>
                <p>结论：如果今天是晴天，那么昨天最有可能是雨天。</p>
                <p>再结合观测概率，算出由昨日雨向今日晴的路径概率：</p>
                <p>$$\delta_2(\text{晴}) = 0.063 \times 0.7 = 0.0441$$</p>
                <p>同理再算出今日阴和今日雨的路径概率：</p>
                <p>$$\delta_2(\text{阴}) = 0.084 \times 0.2 = 0.0168(昨日雨)$$</p>
                <p>$$\delta_2(\text{雨}) = 0.063 \times 0.1 = 0.0063(昨日雨)$$</p>
                <figure>
                    <img src="H2.png" alt="H2">
                    <figcaption>
                        <strong>图 2.</strong> 前两天最佳路径概率（红色标出）
                    </figcaption>
                </figure>
                <h3>2.3 第三天</h3>
                <p>同样计算可得：</p>
                <p>$$\delta_3(\text{晴}) = 0.03087 \times 0.2 = {0.006174}(昨日晴)$$</p>
                <p>$$\delta_3(\text{阴}) = 0.00882 \times 0.3 = {0.002646}(昨日晴)$$</p>
                <p>$$\delta_3(\text{雨}) = 0.00441 \times 0.2 = {0.000882}(昨日晴)$$</p>
                <blockquote>
                    这三个的
                    $\left[ \max_{j' \in \{晴,阴,雨\}} \left( \delta_{2}(j') \times P(x_3 j | x_{2} j') \right) \right]$
                    取最大值时$\delta_{2}(j')$都为$\delta_{2}(晴)$。
                </blockquote>
                <figure>
                    <img src="H3.png" alt="H3">
                    <figcaption>
                        <strong>图 3.</strong> 前三天最佳路径概率（红色标出）
                    </figcaption>
                </figure>
                <h3>2.4 回溯</h3>
                <p>1. 确定终点（第三天）： 比较第三天的三个得分，晴天概率最大，我们取第三天为晴天。</p>
                <p>2. 回溯到第二天：查看 $\delta_3(\text{晴天})$ 的来源记录。我们在上面的步骤中发现，最大值来自 D2 晴天 ($0.0441 \times 0.7$)。$\Rightarrow$ 第二天是：晴天。</p>
                <p>3. 回溯到第一天：查看 $\delta_2(\text{晴天})$ 的来源记录（参考上一轮对话的结论）。我们在上一轮计算中发现，$\delta_2(\text{晴天})$ 的最大贡献者是 D1 雨天 ($0.21 \times 0.3$)。$\Rightarrow$ 第一天是：雨天。</p>
                <p>最终结论：对于观测序列 [睡觉, 跑步, 逛街]，最有可能的天气序列是：$$[{雨天}, {晴天}, {晴天}]$$</p>
                <h2>3. 推广</h2>
                <h3>3.1 符号定义</h3>
                <p>维特比算法（Viterbi Algorithm）的完整数学通式通常分为四个步骤：初始化、递归、终止和回溯。</p>
                <p>$Q = \{q_1, \dots, q_N\}$：所有可能的状态集合（如：晴、阴、雨）。</p>
                <p>$V = \{v_1, \dots, v_M\}$：所有可能的观测集合（如：睡觉、跑步、逛街）。</p>
                <p>$A = [a_{ij}]$：状态转移矩阵（$a_{ij} = P(q_{t+1}=j | q_t=i)$）。</p>
                <p>$B = [b_j(k)]$：发射概率矩阵（$b_j(k) = P(o_t=k | q_t=j)$）。</p>
                <p>$\pi = [\pi_i]$：初始状态概率向量。</p>
                <p>$O = (o_1, \dots, o_T)$：实际的观测序列。</p>
                <h3>3.2 变量定义</h3>
                <p>我们需要两个辅助变量来存储中间结果：</p>
                <p>$\delta_t(i)$：在时刻 $t$ 状态为 $i$ 的最大路径概率。</p>
                <p>$\psi_t(i)$：在时刻 $t$ 状态为 $i$ 的最大概率路径的前一个状态（用于回溯）。</p>
                <h3>3.3 算法流程</h3>
                <h4>1. 初始化</h4>
                <p>计算 $t=1$ 时的局部概率。</p>
                <p>$$\delta_1(i) = \pi_i \times b_i(o_1), \quad 1 \le i \le N$$</p>
                <p>$$\psi_1(i) = 0$$</p>
                <h4>2. 递推</h4>
                <p>计算 $t=2$ 到 $t=T$ 时的局部概率和路径指针。对于 $2 \le t \le T$ 和 $1 \le j \le N$：</p>
                <p>$$\delta_t(j) = \left[ \max_{1 \le i \le N} (\delta_{t-1}(i) \times a_{ij}) \right] \times b_j(o_t)$$</p>
                <p>$$\psi_t(j) = \underset{1 \le i \le N}{\arg\max} \left( \delta_{t-1}(i) \times a_{ij} \right)$$</p>
                <h4>3. 终止</h4>
                <p>在时刻 $T$（最后一天），找出最大的概率值作为整个序列的概率，并找到终点的状态。</p>
                <p>$$P^* = \max_{1 \le i \le N} \delta_T(i)$$</p>
                <p>$$q_T^* = \underset{1 \le i \le N}{\arg\max} \ \delta_T(i)$$</p>
                <h4>4. 回溯</h4>
                <p>从 $T-1$ 往回推，找出最优路径。对于 $t = T-1, T-2, \dots, 1$：</p>
                <p>$$q_t^* = \psi_{t+1}(q_{t+1}^*)$$</p>
            </div>
        </div>

        <div id="footer-placeholder"></div>
    </body>
</html>